cmdhistory=["p" "E" "(E 4)" "(E 1)" "(E 10)" "(E 2)" "(C 1)" "(C 2)" "(play-melody p2 180)" "p2" "(macroexpand-1 '(->> (range 1 (count dur))\\n            (map \#(+ % 65)\\n            (phrase dur))))" "(macroexpand-1 ' (-> (range 1 (count dur))\\n            (map \#(+ % 65)\\n            (phrase dur))))" "(macroexpand-1 ' (->> (range 1 (count dur))\\n            (map \#(+ % 65)\\n            \#(phrase dur %))))" "(macroexpand-1 ' (-> (range 64 (+ 65 (count dur)))\\n            (phrase dur )))" "(macroexpand-1 ' (->> (range 64 (+ 65 (count dur)))\\n            (phrase dur )))" "(macroexpand-1 ' (->> (range 1 (count dur))\\n            (phrase dur )))" "(macroexpand-1 '(->> (range 1 (count dur))\\n            (map \#(+ % 65))\\n            (phrase dur )))" "p2" "(where p2 \:time 110)" "(where \:time 110 p2)" "(core.repl/doc where)" "(repl/doc where)" "(doc for)" "(core.repl/doc for)" "(stop)" "(beep)" "(ping)" "melody" "bass" "(rrb  (bpm 120) (comp scale/C scale/major))" "(rrb (bpm 120) (comp scale/C scale/major))" "cmaj" "bass" "(mapcat (partial repeat 3) [7 4 2 0])" "(rrb (bpm 420) cmaj 4)" "(println \\"fd\\")" "(rrb (bpm 420) cmaj 4)" "pp" "(first pp)" "(second pp)" "(\:keys (second pp))" "(second pp)" "(keys (second pp))" "(values (second pp))" "(doseq [p [1 2 3]] (println p)\\n  )" "(doseq [p [{\:a 1},{\:a 2}]] (println p))" "(rrb (bpm 420) cmaj 4)" "(take 3 pp)" "(take 2 pp)" "(take 1 pp)" "(require 'instaparse.core \:as insta)" "(require '[instaparse.core \:as insta])" "(as-and-bs \\"AAABABBBB\\")" "(as-and-bs \\"aaaaabbbaaaabb\\")" "3" "(+ 3 4)" "(def as-and-bs\\n  (insta/parser\\n    \\"S \= AB*|AC\\n     AB \= A B\\n     AC \= A C\\n     A \= 'a'+\\n     B \= 'b'+\\n     C \= 'c+\\n\\"))" "(as-and-bs \\"aacc\\")" "(f \\"a\\")" "(require '[clojure.string \:as str])" "(str/split \\"fdas fdsa sd f\\" \\" \\")" "(str/split \\"fdsf sdf sdf\\" \#\\" \\")" "(str/split \\"dasfsdfd\\" \#\\"\\")" "*1" "(map \#(concat \\"'\\" % \\"'\\") *1)" "(map str *1)" "3" "3\\n3" "(p 1)" "(mapseq)" "3" "(empt? [])" "(empty? [])" "(first '(a a))" "(rest '(a a fd))" "x" "(first x)" "(printseq '(a b c d))" "(printseq '(a b c))" "(printseq '(a  c d)\\n          )" "x" "(printseq x)" "(printseq '(a (a a))\\n          )" "(printseq '(a ( a a ))\\n          )" "(str \\"3434\\" \\"343')" "(clojure.string/str \\"fdfd\\" \\"Fdf\\")" "(concat \\"fdf\\" \\"Fdf\\")" "(string (concat \\"dfd\\" \\"fd\\"))" "(clojure.string/string [\\"fdsf\\" \\"df\\"])" "(clojure/string.join \\"d\\" \\"fd\\")" "(cloujure.string/join \\"fd\\" \\"Fd\\")" "(empty? '(1))" "(not (empty? '(3 (3)))\\n     )" "(rest '(a f b))" "(rest ((a)))" "(rest '((a))\\n      )" "(rest '( a (b)))" "(atom? 'a)" "(single-valued? 'a)" "(singled-valued? '())" "(single-valued '())" "(single-valued? '())" "(empty? '())" "(empty? ())" "(single-valued? 'a)" "(single-valued? '())" "(empty '())" "(empty ()\\n       )" "(empty? 'a)" "(single-valued? nil)" "(single-valued? ())" "(empty? ())" "(print \\"Fd\\")" "(do (print \\"Fd\\") (print \\"fdf\\"))" "(\= \\"fd\\" \\"Fd\\")" "(nth x 5)" "(first (rest *1))" "*1" "(rest *1)" "(first *1)" "x" "(def a (nth x 5))" "a" "(first (first (rest a)))" "(second x)" "m" "(line-seq m)" "(clojure.string/split-lines m)" "(first lines)" "(f *1)" "(take 3 lines)" "(domap f *1)" "(mapdo)" "d" "2" "g" "(grammar)" "(ff tree)" "3" "(f 3 4)" "tree" "clojure.string/str \\"3)" "(clojure.string/str \\"fd\\")" "(notecommatrans tree)" "tree" "(notecommatran 340)" "(notecommtrans 3)" "(notecommatrans 3)" "(notecommatrans tree)" "{3}" "{3,4}" "(commaNote tree)" "((commaNote) tree)" "tree" "ntree" "tree" "ntree" "tree" "ntree" "(- 4)" "ntree" "(str 3)" "(int \\"3\\")" "(read-string \\"34\\")" "(read-string \\"x\\")" "(/3 4)" "(/ 3 4)" "(read-string \\"3/4\\")" "(str (/ 3 4))" "ntree" "(aposNote)" "m" "(first m)" "(second m)" "tree" "(abcparser \\"G2B2d2g2\\")" "(def commas (countkey \:Commas))" "(commas (abcparser \\"G, 1/3\\"))" "(abcparser \\"G,1/3\\")" "((countkey \:Commas) *1)" "(read-string \\"/\\")" "(read-string \\"34\\")" "(type *1)" "(type *2)" "(type (read-string \\"/\\"))" "(type (read-string \\"34\\"))" "(type (read-string \\"3/4\\"))" "(type [\:Number 3])" "m" "(doseq [i m]\\n  (println i))" "(second '(3 45))" "(def str clojure.string/split-string\\n  )" "(def str clojure.core/str)" "(def splitstr clojure.string/split-string)" "(split-string \\"adfs\\" \#\\"\\")" "(clojure.string/split-string \\"fdf\\" \#\\"\\")" "(clojure.string/split \\"Fdfd\\" \#\\"\\")" "(clojure.string/trim \\"  df  \\")" "(join)" "(clojure.string/join (\\"a\\" \\"b\\"))" "(clojure.string/join \\"x\\" '(\\"a\\" \\"b\\"))" "(clojure.string/join \\",\\" *1)" "x" "grammar" "(c 4)" "(play (c 4))" "(play '(50 1))" "(play-melody p2 60)" "p" "(play-note {\:pitch 3, \:time 0, \:duration 8})" "(plya-note {\:pitch 3, \:time 0, \:duration 8})" "(play-note {\:pitch 3, \:time 0, \:duration 8})" "(play-note {\:pitch 60\\n            \:time 0, \:duration 8}\\n           )" "(c 4)" "p2" "notelista" "(clojure.string/join \\"\\" *1)" "(println notelista)" "notelista" "(clojure.string/toLower \\"A\\")" "notelistb" "(concat \\"fd\\" \\"b\\")" "(println *1)" "split" "(println *1)" "(lower-cse notelista)" "(lower-case notelista)" "(concat [1,3] [3,4])" "(concat [1,3] '(3,5))" "notes" "noteslista" "notelista" "notelistb" "(concat na nb)" "midi-values" "(range 10 20)" "(count n)" "(clojure.zip/zip [1,3] [3 4])" "(midi-map \\"G\\")" "(\\"G\\" midi-map)" "(midi-map \\"G\\")" "midi-ap" "midi-map" "oddnotes" "(slurp \\"abcLH.txt\\")" " InputStream res \=\\n    Main.class.getResourceAsStream(\\"/my-resource.txt\\");\\n\\n    BufferedReader reader \=\\n        new BufferedReader(new InputStreamReader(res));\\n    String line \= null;\\n    while ((line \= reader.readLine()) \!\= null) {\\n        System.out.println(line);\\n    }\\n    reader.close();" "(.getClass)" "(clojure.java.io/resource \\"abcLH.txt\\")" "m" "(printseq m)" "grammar" "m" "(take 1 m)" "(type m)" "(m 2)" "x" "(def x (m 2))" "x" "(abcparser x)" "(abcparser (m 1))" "(m 1)" "parsed" "( m 1)" "parsed" "3" "3\\n\\n33" "3" "3\\n3\\n3\\n3\\n3\\n3\\n3\\n\\n3\\n3" "(run-tests)" "(runtests)" "(run-tests)" "(run-all-tests)" "(run-test)" "(run-tests)" "(addition)" "(run-test addition)" "(run-tests)" "(run-test)" "(run-tests)" "(abcparser \\"G\\")" "midi-map" "m" "4" "4\\n4\\n4\\n4" "4\\n4\\n4" "(for [[k,v] testmap]\\n               `(is (\= (applytrans (abcparser ~k)) ~v)))" "body" "`(f ~@body)" "tests" "x" "notes" "p2" "(play p2)" "p3" "nn" "dur" "p3" "3" "3\\n33" "3\\n3\\n3" "((bpm 90) 5)" "(bpm 90)" "p3" "(repeat 4)" "3" "(map \#(-> triad (root %)) [0 3 4 3])" "(type \:i)" "(root 1 triad)" "(root 3 triad)" "(root 3)" "(root triad 3)" "(phrase (1 1 1) *1)" "(phrase (repeat 1) (root triad 3))" "3" "3\\n333" "(phrase [1 [1 2]] [4 3])" "(phrase [1/2 1/2 3/2 3/2] [0 1 nil 4])" "((bpm 60) 1)" "((bpm 60) 1/4)" "((bpm 60) 1)" "((bpm 60) 2)" "((bpm 500) 1)" "((bpm 60) 1/2)" "((bpm 120) 1/2)" "omp/MIDDLE-C" "(omp/octave-note 5 1)" "(omp/octave-note 5 0)" "(om/note-info \\"C4\\")" "(om/note-info \\"Cb4\\")" "(om/note-info \\"c\#4\\")" "[a,b,c]" "(def x (applytrans (abcparser \\"G,,/\\")))" "(aa\\n  )" "aa" "(rh 1)" "(type rh)" "rh" "(rh 1)" "rh" "(nth rh 2)" "((vector rh) 3)" "(def xxx (apply vector rh))" "(xxx 3)" "(rh 1)" "aa" "(cloure.string/is-loer \\"a\\")" "(clojure.string/lower-case \\"a\\")" "(clojure.string/lower-case? \\"a\\")" "(Character/isUpperCase \\"a\\")" "(.isUpperCase \\"a\\")" "whichoctave" "notelist" "rh" "(count [1,3,3])" "midi-map" "'b" "(str 'b)" "(second '(3 4))" "midima" "midi-map" "notelist" "(rest [1,3,3])" "(read-string \\"_c\\")" "(read-string \\"_C\\")" "3" "3\\n3\\n3\\n3" "(note-info \\"C4\\")" "(note-info \\"C\#4\\")" "(note-info \\"C4\\")" "(rrb (bpm 420) cmaj 4)" "pp" "(note-info \\"c4\\")" "3" "3\\n3\\n3" "(rh 1)" "pp" "melodh" "melody" "rest" "melody" "(note-info \\"a5\\")" "(\:midi-note (note-info \\"a5\\"))" "melody" "x" "(definst saw-wave [freq 440 attack 0.01 sustain 0.4 release 0.1 vol 0.4] \\n  (* (env-gen (env-lin attack sustain release) 1 1 0 1 FREE)\\n     (saw freq)\\n     vol))" "(use 'overtone.live)" "(ol/phrase)" "(definst foo[] (saw 220))" "(ol/definst )" "(ol/definst foo[] (saw 220))" "(use 'overtone.live)" "(midi->hz \:A4)" "(use 'overtone.live)" "(use 'overtone.piano.inst)" "(use 'overtone.inst.piano)" "(piano 34)" "(piano \\"A4\\")" "(piano (note \:A4))" "(note \:A4)" "(piano (note \\"A4\\"))" "(piano \:a4)" "(piano \:A4)" "(piano (note \:a4))" "(chord \:C4 \:major)" "(play-chord (chord \:c4 \:major) piano)" "(metro)" "(use 'overtone.piano.inst)" "(use 'overtone.live)" "(use 'overtone.piano.inst)" "(use 'overtone.inst.piano)" "(vector [1,2] [3,4])" "(map vector [1,2] [3,4])" "(def x inc 1)" "(def x (iterate inc 1))" "(take 10 x)" "(def x (iterate \#(+ 4) 1))" "(take 10 x)" "(def x (iterate \#(+ 4 %) 1))" "(take 10 x)" "(map vector x [1,2,3])" "(take 10 (make-beats 10))" "(chord \:G3)" "(chord \:g3 \:major)" "(bpm 30\\n     )" "(bmp 30)" "(bpm 30)" "(bpm 120)" "(bpm 30)" "chords" "(take 10 \\n      (make-beats 30))" "(def x (make-beats 60))" "(type x)" "(take 10 x)" "(bpm 30)" "(take 10 (make-beats 60))" "(def x (make-beats 60))" "(take 10 x)" "(take 10 (make-beats 60))" "(take 10 (make-beats 3))" "(take 10 (make-beats 10))" "(take 10 (repeat 3))" "notes" "(now)" "(date (now))" "(.getTime (now))" "t" "(reductions + (range 10))" "(append 0 '( 4 4))" "(cons 3 '(43 434))" "(time-from-durations [1 2 1])" "(time-from-durations [2,2,2])" "(time-from-durations [1,2,3])" "(use '(incanter core charts))" "(map vector [1,2] [3,4])" "(take 10 (iterate \#(+ 500 %) 0 ))" "(doseq [a,b] [1,2] [3,4] (println a b))" "[[1,2] [3,4]]" "[[1 3] 6]" "[1,\\"dog\\",[1,23]]" "(now)" "(reductions + (range 10))" "(/ 60000 60)" "(bpm 120)" "(bpm 120 1/4)" "phrase" "(phrase)" "(phrase [1,2], [3,4])" "(phrase [1,2,3] [1,2,3])" "(phrase [1,2,3] [2,34,3])" "{\:d 3, \:a 4}" "(phrase [1,2] [3,4])" "(map-hash 1 3 4 4)" "(hash 1 2 4 4)" "(hash-map 1 2 3 4)" "(phrase [2,3] [4,5])" "(phrase [1,2] [3,4])" "(conj 3 [2])" "(con 3 '(3 4)\\n     )" "(cons 3 '(3 4))" "(cons 3 [3 4])" "(conj 3 [4])" "(phrase [1/2 1/2] [\:b4 \:c4])" "where" "p" "(bpm 60)" "(id 4)" "(identity 4)" "(concat [3 4] [4])" "(type \:c)" "(type [3])" "(\= (type [3]) clojure.lang.PersistentVector)" "(beep 60)" "(ping)" "(\#(* % 3) 5)" "(type '\#.)" "\#." "(defn \!.[x] (+ x 1))" "(\!. 3)" "(take 10 (repeat 3))" "(mapcat \#(repeat 3) [4 5])" "(mapcat \#(repeat %) [4 5])" "(mapcat \#(repeat 3 %) [4,5])" "(time (apply + (map + (range 1000000) (range 1000000))))" "(time (reduce\\n        + (map + (range 1000000) (range 1000000))))" "bass" "(printseq bass)" "(pprint)" "(use 'clojure.pprint)" "(pprint (range 10))" "(pprint bass)" "(pprint melody)" "(row-row 120 (comp C major))" "(row-row (bpm 120) (comp C major))" "(pprint *1)" "(pprint base)" "(pprint bass)" "(pitch 76)" "(pprint 3)" "(clojure.pprint/pprint 30)" "(pprint 30\\n        )" "(pprint 3)" "(ping)" "(beep)" "(seeth 2)" "(seeth 5)" "(ping)" "(play *1)" "(pint)" "(ping)" "song0" "song" "(play song)" "(piano)" "(piano0\\n  )" "(piano)" "(overtone.inst.piano/piano)" "(piano)" "(use 'overtone.inst.piano)" "(piano)" "(import '[org.opencv.core Mat ])" "(import '[opencv.core Mat])" "(import '[org.opencv.core Mat CvType Scalar])" "(org.opencv.cre.Point 0 0)" "(import 'org.opencv.core.Point)" "(import 'opencv.core.Point)" "(import 'org.opencv.core.Point)" "(import 'org.opencv.core.Core/NATIVE_LIBRARY_NAME)"]
eclipse.preferences.version=1
